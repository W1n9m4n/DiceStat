<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dice Pip Detector (iPhone Friendly)</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  video, canvas { border: 1px solid black; max-width: 100%; height: auto; }
  #history { margin-top: 20px; }
  table { border-collapse: collapse; width: 100%; }
  td, th { border: 1px solid #ccc; padding: 5px 10px; text-align: center; }
  button { font-size: 1.2rem; padding: 10px 20px; margin-bottom: 10px; }
</style>
</head>
<body>
<h1>Dice Pip Detector</h1>
<button id="startBtn">Start Camera</button><br />
<video id="video" width="640" height="480" autoplay muted playsinline></video>
<canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

<h2>Current Dice Count</h2>
<div id="currentCount">Press "Start Camera" to begin</div>

<h2>History</h2>
<table id="history">
  <thead><tr><th>Timestamp</th><th>Pip Value</th><th>Count</th></tr></thead>
  <tbody></tbody>
</table>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
<script>
  let video = document.getElementById('video');
  let canvas = document.getElementById('canvas');
  let ctx = canvas.getContext('2d');
  let currentCountDiv = document.getElementById('currentCount');
  let historyTableBody = document.querySelector('#history tbody');
  let startBtn = document.getElementById('startBtn');

  let streaming = false;
  let src, gray, blurred, thresh, contours, hierarchy;

  function onOpenCvReady() {
    console.log('OpenCV.js is ready');
    startBtn.disabled = false;
  }

  startBtn.addEventListener('click', () => {
    startBtn.disabled = true;
    startCamera();
  });

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
      video.srcObject = stream;
      await video.play();
      streaming = true;
      initCvObjects();
      processVideo();
    } catch (err) {
      alert('Cannot access camera: ' + err);
      startBtn.disabled = false;
    }
  }

  function initCvObjects() {
    src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    gray = new cv.Mat();
    blurred = new cv.Mat();
    thresh = new cv.Mat();
    contours = new cv.MatVector();
    hierarchy = new cv.Mat();
  }

  function processVideo() {
    if (!streaming) {
      cleanup();
      return;
    }

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    src.data.set(imageData.data);

    // Grayscale
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    // Blur
    cv.GaussianBlur(gray, blurred, new cv.Size(7,7), 1.5, 1.5, cv.BORDER_DEFAULT);

    // Adaptive threshold
    cv.adaptiveThreshold(blurred, thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 15, 5);

    // Find contours
    cv.findContours(thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

    // Get contour centers
    let centers = [];
    for (let i = 0; i < contours.size(); i++) {
      let cnt = contours.get(i);
      let moments = cv.moments(cnt);
      if (moments.m00 > 10) {
        let cx = moments.m10 / moments.m00;
        let cy = moments.m01 / moments.m00;
        centers.push({x: cx, y: cy});
      }
      cnt.delete();
    }

    // Group centers by proximity
    let diceClusters = [];
    let clusterDistance = 50;

    centers.forEach(center => {
      let foundCluster = false;
      for (let cluster of diceClusters) {
        for (let c of cluster) {
          let dx = c.x - center.x;
          let dy = c.y - center.y;
          if (Math.sqrt(dx*dx + dy*dy) < clusterDistance) {
            cluster.push(center);
            foundCluster = true;
            break;
          }
        }
        if (foundCluster) break;
      }
      if (!foundCluster) {
        diceClusters.push([center]);
      }
    });

    // Count pips per cluster
    let pipCounts = {};
    diceClusters.forEach(cluster => {
      let count = cluster.length;
      if (count > 0 && count <= 6) {
        pipCounts[count] = (pipCounts[count] || 0) + 1;
      }
    });

    if (Object.keys(pipCounts).length === 0) {
      currentCountDiv.textContent = "No dice detected";
    } else {
      currentCountDiv.innerHTML = '';
      for (let pip in pipCounts) {
        let p = document.createElement('p');
        p.textContent = `${pipCounts[pip]} dice with ${pip} pip${pip > 1 ? 's' : ''}`;
        currentCountDiv.appendChild(p);
      }

      let now = new Date().toLocaleTimeString();
      for (let pip in pipCounts) {
        let row = document.createElement('tr');
        row.innerHTML = `<td>${now}</td><td>${pip}</td><td>${pipCounts[pip]}</td>`;
        historyTableBody.prepend(row);
      }
      while (historyTableBody.rows.length > 20) {
        historyTableBody.deleteRow(historyTableBody.rows.length - 1);
      }
    }

    setTimeout(processVideo, 500);
  }

  function cleanup() {
    if (src) src.delete();
    if (gray) gray.delete();
    if (blurred) blurred.delete();
    if (thresh) thresh.delete();
    if (contours) contours.delete();
    if (hierarchy) hierarchy.delete();
  }
</script>
</body>
</html>
