<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dice Pip Detector</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  video, canvas { border: 1px solid black; }
  #history { margin-top: 20px; }
  table { border-collapse: collapse; }
  td, th { border: 1px solid #ccc; padding: 5px 10px; }
</style>
</head>
<body>
<h1>Dice Pip Detector</h1>
<video id="video" width="640" height="480" autoplay muted></video>
<canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

<h2>Current Dice Count</h2>
<div id="currentCount">Detecting...</div>

<h2>History</h2>
<table id="history">
  <thead><tr><th>Timestamp</th><th>Pip Value</th><th>Count</th></tr></thead>
  <tbody></tbody>
</table>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
<script>
  let video = document.getElementById('video');
  let canvas = document.getElementById('canvas');
  let ctx = canvas.getContext('2d');
  let currentCountDiv = document.getElementById('currentCount');
  let historyTableBody = document.querySelector('#history tbody');

  let streaming = false;
  let src, gray, blurred, thresh, contours, hierarchy;

  function onOpenCvReady() {
    console.log('OpenCV.js is ready');
    startCamera();
  }

  function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(function(stream) {
        video.srcObject = stream;
        video.play();
      })
      .catch(function(err) {
        alert('Cannot access camera: ' + err);
      });

    video.addEventListener('canplay', function() {
      if (!streaming) {
        streaming = true;
        initCvObjects();
        processVideo();
      }
    });
  }

  function initCvObjects() {
    src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
    gray = new cv.Mat();
    blurred = new cv.Mat();
    thresh = new cv.Mat();
    contours = new cv.MatVector();
    hierarchy = new cv.Mat();
  }

  function processVideo() {
    if (!streaming) {
      // clean up
      src.delete(); gray.delete(); blurred.delete(); thresh.delete();
      contours.delete(); hierarchy.delete();
      return;
    }

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    src.data.set(imageData.data);

    // Convert to grayscale
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    // Blur to reduce noise
    cv.GaussianBlur(gray, blurred, new cv.Size(7,7), 1.5, 1.5, cv.BORDER_DEFAULT);

    // Threshold to binary image (bright dots on dice)
    cv.adaptiveThreshold(blurred, thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 15, 5);

    // Find contours (potential pips)
    cv.findContours(thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

    // We'll try a very simple approach:
    // - Group nearby contours as one die
    // - Count pips inside each die
    // This is a naive method, but good for a start

    // Get contours centers
    let centers = [];
    for (let i = 0; i < contours.size(); i++) {
      let cnt = contours.get(i);
      let moments = cv.moments(cnt);
      if (moments.m00 > 10) { // filter tiny contours
        let cx = moments.m10 / moments.m00;
        let cy = moments.m01 / moments.m00;
        centers.push({x: cx, y: cy});
      }
      cnt.delete();
    }

    // Group centers by proximity (dice clusters)
    let diceClusters = [];
    let clusterDistance = 50; // pixels

    centers.forEach(center => {
      let foundCluster = false;
      for (let cluster of diceClusters) {
        for (let c of cluster) {
          let dx = c.x - center.x;
          let dy = c.y - center.y;
          if (Math.sqrt(dx*dx + dy*dy) < clusterDistance) {
            cluster.push(center);
            foundCluster = true;
            break;
          }
        }
        if (foundCluster) break;
      }
      if (!foundCluster) {
        diceClusters.push([center]);
      }
    });

    // Count pips per die cluster
    let pipCounts = {};
    diceClusters.forEach(cluster => {
      let count = cluster.length;
      if (count > 0 && count <= 6) { // dice have max 6 pips
        pipCounts[count] = (pipCounts[count] || 0) + 1;
      }
    });

    // Display current count
    if (Object.keys(pipCounts).length === 0) {
      currentCountDiv.textContent = "No dice detected";
    } else {
      currentCountDiv.innerHTML = '';
      for (let pip in pipCounts) {
        let p = document.createElement('p');
        p.textContent = `${pipCounts[pip]} dice with ${pip} pip${pip > 1 ? 's' : ''}`;
        currentCountDiv.appendChild(p);
      }

      // Add to history
      let now = new Date().toLocaleTimeString();
      for (let pip in pipCounts) {
        let row = document.createElement('tr');
        row.innerHTML = `<td>${now}</td><td>${pip}</td><td>${pipCounts[pip]}</td>`;
        historyTableBody.prepend(row);
      }

      // Limit history rows to 20
      while (historyTableBody.rows.length > 20) {
        historyTableBody.deleteRow(historyTableBody.rows.length - 1);
      }
    }

    // Schedule next frame
    setTimeout(processVideo, 500);
  }
</script>
</body>
</html>
