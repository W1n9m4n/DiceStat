<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DiceStat with Roboflow Workflow</title>
  <style>
    body { font-family: sans-serif; padding: 2em; max-width: 800px; margin: auto; }
    video, canvas, img { max-width: 100%; margin-top: 1em; }
    #results { margin-top: 1em; font-weight: bold; }
    label { display: block; margin-top: 1em; }
    #confidenceValue { font-weight: normal; }
    .bounding-box {
      position: absolute;
      border: 2px solid red;
      pointer-events: none;
      color: white;
      background-color: rgba(0,0,0,0.5);
      padding: 2px 5px;
      font-size: 14px;
    }
    #wrapper {
      position: relative;
      display: inline-block;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>

<h1>DiceStat (Workflow)</h1>

<label><input type="radio" name="mode" value="upload" checked> Upload Image</label>
<label><input type="radio" name="mode" value="video"> Use Webcam Video</label>

<div id="uploadSection">
  <input type="file" id="uploadInput" accept="image/*" />
</div>

<div id="videoSection" style="display:none;">
  <video id="video" autoplay playsinline width="640" height="480"></video>
</div>

<div id="wrapper">
  <img id="preview" alt="Preview Image" />
  <canvas id="canvas"></canvas>
</div>

<label>
  Confidence threshold: <span id="confidenceValue">0.25</span>
  <input type="range" id="confidenceSlider" min="0" max="1" step="0.01" value="0.25" />
</label>

<div id="results"></div>

<script>
  const API_KEY = "hcMpxDXEVyytWxlYcR00";
  const WORKFLOW_URL = "https://serverless.roboflow.com/infer/workflows/dicestat-d6/dicecounter-v01";

  const uploadInput = document.getElementById("uploadInput");
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const preview = document.getElementById("preview");
  const resultsDiv = document.getElementById("results");
  const confidenceSlider = document.getElementById("confidenceSlider");
  const confidenceValue = document.getElementById("confidenceValue");
  const modeRadios = document.querySelectorAll('input[name="mode"]');

  let videoStream = null;
  let intervalId = null;

  modeRadios.forEach(radio => {
    radio.addEventListener("change", () => {
      if (radio.value === "upload") {
        stopVideoStream();
        document.getElementById("uploadSection").style.display = "block";
        document.getElementById("videoSection").style.display = "none";
        clearResults();
      } else {
        startVideoStream();
        document.getElementById("uploadSection").style.display = "none";
        document.getElementById("videoSection").style.display = "block";
        clearResults();
      }
    });
  });

  confidenceSlider.addEventListener("input", () => {
    confidenceValue.textContent = confidenceSlider.value;
  });

  uploadInput.addEventListener("change", () => {
    if (!uploadInput.files[0]) return;
    const reader = new FileReader();
    reader.onloadend = () => {
      preview.src = reader.result;
      drawAndSend(reader.result);
    };
    reader.readAsDataURL(uploadInput.files[0]);
  });

  async function startVideoStream() {
    try {
      videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = videoStream;
      video.play();
      intervalId = setInterval(() => {
        captureFrameFromVideo();
      }, 10000);
    } catch (err) {
      resultsDiv.textContent = "Webcam error: " + err.message;
    }
  }

  function stopVideoStream() {
    if (intervalId) clearInterval(intervalId);
    if (videoStream) {
      videoStream.getTracks().forEach(t => t.stop());
      videoStream = null;
    }
    preview.src = "";
  }

  function captureFrameFromVideo() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);
    const dataUrl = canvas.toDataURL("image/jpeg");
    preview.src = dataUrl;
    drawAndSend(dataUrl);
  }

  function clearResults() {
    resultsDiv.textContent = "";
    preview.src = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function drawAndSend(dataUrl) {
    canvas.width = preview.width;
    canvas.height = preview.height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    sendToRoboflow(dataUrl, parseFloat(confidenceSlider.value));
  }

  function sendToRoboflow(imageData, confidence) {
    resultsDiv.textContent = "Detecting...";
    fetch(`${WORKFLOW_URL}?api_key=${API_KEY}&confidence=${confidence}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ image: imageData })
    })
      .then(res => res.json())
      .then(data => {
        console.log("Workflow response:", data);
        const detections = data?.results?.[0]?.predictions || [];
        displayResults(detections);
      })
      .catch(err => {
        resultsDiv.textContent = "Detection error: " + err.message;
      });
  }

  function displayResults(predictions) {
    if (!predictions.length) {
      resultsDiv.innerHTML = "<strong>No dice detected.</strong>";
      return;
    }

    let total = 0;
    let rolls = [];

    predictions.forEach(pred => {
      const val = parseInt(pred.class, 10);
      if (!isNaN(val)) total += val;
      rolls.push(val);

      // Draw box
      const x = pred.x - pred.width / 2;
      const y = pred.y - pred.height / 2;
      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, pred.width, pred.height);

      // Label
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(x, y - 20, 24, 20);
      ctx.fillStyle = "white";
      ctx.font = "14px sans-serif";
      ctx.fillText(val, x + 5, y - 5);
    });

    resultsDiv.innerHTML = `
      <strong>Dice detected:</strong> ${rolls.length}<br>
      <strong>Total sum:</strong> ${total}<br>
      <strong>Individual rolls:</strong> ${rolls.join(", ")}
    `;
  }
</script>
</body>
</html>
