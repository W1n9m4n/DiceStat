<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>DiceStat Video + Image Detection</title>
<style>
  body { font-family: sans-serif; padding: 2em; max-width: 600px; margin: auto; }
  video, canvas, img { max-width: 100%; margin-top: 1em; }
  #results { margin-top: 1em; font-weight: bold; }
  label { display: block; margin-top: 1em; }
  #confidenceValue { font-weight: normal; }
  #canvas { position: relative; }
</style>
</head>
<body>

<h1>DiceStat</h1>

<p>Select mode:</p>
<label><input type="radio" name="mode" value="upload" checked> Upload Image</label>
<label><input type="radio" name="mode" value="video"> Use Webcam Video</label>

<div id="uploadSection">
  <input type="file" id="uploadInput" accept="image/*" />
</div>

<div id="videoSection" style="display:none;">
  <video id="video" autoplay playsinline></video>
</div>

<canvas id="canvas" style="display:none;"></canvas>
<img id="preview" alt="Preview Image" style="display:none;"/>

<label>
  Confidence threshold: <span id="confidenceValue">0.25</span>
  <input type="range" id="confidenceSlider" min="0" max="1" step="0.01" value="0.25" />
</label>

<div id="results"></div>

<script>
  const API_URL = "https://infer.roboflow.com/dicestat-d6/dicecounter-v01";
  const API_KEY = "hcMpxDXEVyytWxlYcR00";

  const modeRadios = document.querySelectorAll('input[name="mode"]');
  const uploadSection = document.getElementById("uploadSection");
  const videoSection = document.getElementById("videoSection");
  const uploadInput = document.getElementById("uploadInput");
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const preview = document.getElementById("preview");
  const resultsDiv = document.getElementById("results");
  const confidenceSlider = document.getElementById("confidenceSlider");
  const confidenceValue = document.getElementById("confidenceValue");

  let videoStream = null;
  let intervalId = null;

  // Mode toggle
  modeRadios.forEach(radio => {
    radio.addEventListener("change", () => {
      if (radio.value === "upload" && radio.checked) {
        stopVideoStream();
        uploadSection.style.display = "block";
        videoSection.style.display = "none";
        canvas.style.display = "none";
        preview.style.display = "block";
        clearResults();
      } else if (radio.value === "video" && radio.checked) {
        uploadSection.style.display = "none";
        videoSection.style.display = "block";
        preview.style.display = "none";
        canvas.style.display = "block";
        startVideoStream();
        clearResults();
      }
    });
  });

  // Confidence slider update
  confidenceSlider.addEventListener("input", () => {
    confidenceValue.textContent = confidenceSlider.value;
  });

  // Upload image handler
  uploadInput.addEventListener("change", () => {
    if (!uploadInput.files[0]) return;
    const reader = new FileReader();
    reader.onloadend = () => {
      preview.src = reader.result;
      preview.style.display = "block";
      canvas.style.display = "none";
      sendToRoboflow(reader.result, parseFloat(confidenceSlider.value));
    };
    reader.readAsDataURL(uploadInput.files[0]);
  });

  // Start webcam
  async function startVideoStream() {
    try {
      videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = videoStream;
      video.play();

      // Capture every 10 seconds
      intervalId = setInterval(captureFrameFromVideo, 10000);
    } catch (err) {
      resultsDiv.textContent = "Error accessing webcam: " + err.message;
    }
  }

  function stopVideoStream() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
    if (videoStream) {
      videoStream.getTracks().forEach(track => track.stop());
      videoStream = null;
    }
    preview.src = "";
    canvas.style.display = "none";
  }

  // Capture frame from video and send to Roboflow
  function captureFrameFromVideo() {
    if (!video.videoWidth || !video.videoHeight) return;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataUrl = canvas.toDataURL("image/jpeg");
    sendToRoboflow(dataUrl, parseFloat(confidenceSlider.value));
  }

  // Clear results display
  function clearResults() {
    resultsDiv.textContent = "";
    // Clear canvas too
    if (canvas.style.display !== "none") {
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  }

  // Send base64 image to Roboflow Hosted API (GET request)
  function sendToRoboflow(dataUrl, confidence) {
    resultsDiv.textContent = "Detecting...";
    const base64Data = dataUrl.replace(/^data:image\/\w+;base64,/, "");
    const url = `${API_URL}?api_key=${API_KEY}&confidence=${confidence}&image=${encodeURIComponent(base64Data)}`;

    fetch(url)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        return res.json();
      })
      .then(json => {
        if (json.message) {
          resultsDiv.textContent = "Error: " + json.message;
          return;
        }
        drawBoxes(json);
        displayResults(json, confidence);
      })
      .catch(err => {
        resultsDiv.textContent = "Error: " + err.message;
      });
  }

  // Draw bounding boxes on canvas with dice number labels
  function drawBoxes(data) {
    if (canvas.style.display === "none") return;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!data.predictions || data.predictions.length === 0) return;

    ctx.lineWidth = 3;
    ctx.font = "20px Arial";
    ctx.strokeStyle = "red";
    ctx.fillStyle = "red";

    data.predictions.forEach(pred => {
      // Bounding box coordinates in pixels
      const x = pred.x - pred.width / 2;
      const y = pred.y - pred.height / 2;
      const w = pred.width;
      const h = pred.height;

      // Draw rectangle
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.stroke();

      // Draw detected dice number as label
      ctx.fillText(pred.class, x + 5, y + 20);
    });
  }

  // Display detection results summary
  function displayResults(data, confidence) {
    const predictions = data.predictions || [];
    if (!predictions.length) {
      resultsDiv.innerHTML = `<strong>No dice detected (threshold: ${confidence})</strong>`;
      return;
    }

    let total = 0;
    let rolls = predictions.map(p => {
      const val = parseInt(p.class, 10);
      total += val;
      return val;
    });

    resultsDiv.innerHTML = `
      <strong>Confidence threshold:</strong> ${confidence}<br>
      <strong>Dice detected:</strong> ${rolls.length}<br>
      <strong>Total sum:</strong> ${total}<br>
      <strong>Individual rolls:</strong> ${rolls.join(", ")}
    `;
  }
</script>

</body>
</html>
