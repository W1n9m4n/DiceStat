<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DiceStat - Dice Detection</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
      max-width: 800px;
      margin: auto;
    }
    video, canvas, img {
      max-width: 100%;
      margin-top: 1em;
    }
    #results {
      margin-top: 1em;
      font-weight: bold;
    }
    label {
      display: block;
      margin-top: 1em;
    }
    #confidenceValue {
      font-weight: normal;
    }
  </style>
</head>
<body>

  <h1>DiceStat</h1>

  <p>Select mode:</p>
  <label><input type="radio" name="mode" value="upload" checked> Upload Image</label>
  <label><input type="radio" name="mode" value="video"> Use Webcam Video</label>

  <div id="uploadSection">
    <input type="file" id="uploadInput" accept="image/*" />
  </div>

  <div id="videoSection" style="display:none;">
    <video id="video" autoplay playsinline></video>
  </div>

  <canvas id="canvas"></canvas>

  <label>
    Confidence threshold: <span id="confidenceValue">0.25</span>
    <input type="range" id="confidenceSlider" min="0" max="1" step="0.01" value="0.25" />
  </label>

  <div id="results"></div>

  <script>
    const API_URL = "https://detect.roboflow.com/dicecounter-v01/1"; // Workflow endpoint
    const API_KEY = "hcMpxDXEVyytWxlYcR00";

    const modeRadios = document.querySelectorAll('input[name="mode"]');
    const uploadSection = document.getElementById("uploadSection");
    const videoSection = document.getElementById("videoSection");
    const uploadInput = document.getElementById("uploadInput");
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const resultsDiv = document.getElementById("results");
    const confidenceSlider = document.getElementById("confidenceSlider");
    const confidenceValue = document.getElementById("confidenceValue");

    let videoStream = null;
    let intervalId = null;

    modeRadios.forEach(radio => {
      radio.addEventListener("change", () => {
        if (radio.value === "upload" && radio.checked) {
          stopVideoStream();
          uploadSection.style.display = "block";
          videoSection.style.display = "none";
          clearResults();
        } else if (radio.value === "video" && radio.checked) {
          uploadSection.style.display = "none";
          videoSection.style.display = "block";
          startVideoStream();
          clearResults();
        }
      });
    });

    confidenceSlider.addEventListener("input", () => {
      confidenceValue.textContent = confidenceSlider.value;
    });

    uploadInput.addEventListener("change", () => {
      if (!uploadInput.files[0]) return;
      const reader = new FileReader();
      reader.onloadend = () => {
        const img = new Image();
        img.onload = () => {
          drawAndSend(img);
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(uploadInput.files[0]);
    });

    async function startVideoStream() {
      try {
        videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = videoStream;
        video.play();
        intervalId = setInterval(captureFrameFromVideo, 10000);
      } catch (err) {
        resultsDiv.textContent = "Error accessing webcam: " + err.message;
      }
    }

    function stopVideoStream() {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
      }
    }

    function captureFrameFromVideo() {
      if (!video.videoWidth || !video.videoHeight) return;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const dataUrl = canvas.toDataURL("image/jpeg");
      sendToRoboflow(dataUrl, parseFloat(confidenceSlider.value));
    }

    function drawAndSend(img) {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      sendToRoboflow(canvas.toDataURL("image/jpeg"), parseFloat(confidenceSlider.value));
    }

    function clearResults() {
      resultsDiv.innerHTML = "";
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function sendToRoboflow(dataUrl, confidence) {
      resultsDiv.textContent = "Detecting...";
      const base64Data = dataUrl.replace(/^data:image\/\w+;base64,/, "");

      fetch(`${API_URL}?api_key=${API_KEY}&confidence=${confidence}`, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: base64Data
      })
        .then(res => res.json())
        .then(json => {
          console.log("Workflow response:", json);

          let preds = [];
          try {
            preds = json.outputs && Array.isArray(json.outputs)
              ? json.outputs[0]?.predictions || []
              : [];
          } catch (e) {
            console.error("Error parsing predictions:", e);
            resultsDiv.textContent = "Error: Could not read predictions.";
            return;
          }

          if (!Array.isArray(preds)) {
            resultsDiv.textContent = "Error: Unexpected prediction format.";
            return;
          }

          displayResults(preds, confidence);
        })
        .catch(err => {
          resultsDiv.textContent = "Error: " + err.message;
        });
    }

    function displayResults(predictions, confidence) {
      if (!predictions.length) {
        resultsDiv.innerHTML = `<strong>No dice detected (threshold: ${confidence})</strong>`;
        return;
      }

      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.font = "20px Arial";
      ctx.fillStyle = "#00FF00";

      let total = 0;
      const values = [];

      predictions.forEach(p => {
        const val = parseInt(p.class, 10);
        if (!isNaN(val)) {
          total += val;
          values.push(val);
        }

        // Draw bounding box
        const x = p.x - p.width / 2;
        const y = p.y - p.height / 2;
        ctx.strokeRect(x, y, p.width, p.height);
        ctx.fillText(p.class, x + 4, y + 20);
      });

      resultsDiv.innerHTML = `
        <strong>Confidence threshold:</strong> ${confidence}<br>
        <strong>Dice detected:</strong> ${values.length}<br>
        <strong>Total sum:</strong> ${total}<br>
        <strong>Individual rolls:</strong> ${values.join(", ")}
      `;
    }
  </script>
</body>
</html>
